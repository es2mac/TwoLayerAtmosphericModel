// @ts-nocheck

import("types.nools");

global SPACE = "space";
global SUN = "sun";
global LAYER1 = "layer1";
global LAYER2 = "layer2";
global SURFACE = "surface";

global diagramButtons = [SUN, SPACE, LAYER1, LAYER2, SURFACE];

function getImageName(label, active) {
    if (active) {
        return "Assets/" + label + "-active.png";
    } else {
        return "Assets/" + label + "-inactive.png";
    }
}

rule Bootstrap {
    when {
        bool : Boolean bool == false from false;
    }
    then {
        // Create Problem
        assert(new Problem("twoLayers"));

        // Step 1 diagram buttons
        assert(new InterfaceElement(SPACE));
        assert(new InterfaceElement(SUN));
        assert(new InterfaceElement(LAYER2));
        assert(new InterfaceElement(LAYER1));
        assert(new InterfaceElement(SURFACE));

        // Step 1 all arrows
        let arrows = [
            assert(new Arrow("arrow1", SUN, SURFACE, "S(1-α)/4" )),
            assert(new Arrow("arrow2", SURFACE, LAYER1, "σTs^4" )),
            assert(new Arrow("arrow3", LAYER1, SURFACE, "σT1^4" )),
            assert(new Arrow("arrow4", LAYER1, LAYER2, "σT1^4" )),
            assert(new Arrow("arrow5", LAYER2, LAYER1, "σT2^4" )),
            assert(new Arrow("arrow6", LAYER2, SPACE, "σT2^4" ))
        ];
        for (arrow of arrows) {
            assert(new InterfaceElement(arrow.ieEnergyBox));
            assert(new InterfaceElement(arrow.ieEnergyText));
            assert(new TPA(arrow.name, "SetVisible", false));
            assert(new TPA(arrow.ieEnergyBox, "SetVisible", false));
            assert(new TPA(arrow.ieEnergyText, "SetVisible", false));
        }

        // CTAT settings
        setProblemAttribute("use_backtracking", true);
        setProblemAttribute("prune_old_activations", true);
        // setProblemAttribute("substitute_input", true);
        halt();
    }
}

rule SelectTransferFromBody {
    when {
        p: Problem p.subgoal == "selectTransferBodies" && !p.selectedFromBody;
        ie: InterfaceElement ie.name in diagramButtons {name: selection};
    }
    then {
        if (checkSAI({selection: selection, action: "ButtonPressed", input: -1})) {
            modify(p, "selectedFromBody", selection);
            assert(new TPA(selection, "assignImage", getImageName(selection, true)));
            halt();
        } else {
            backtrack();
        }
    }
}

// Problem: sometimes can't click on the same button twice, even using TPA unlock
// rule UnselectTransferFromBody {
//     when {
//         p: Problem p.subgoal == "selectTransferBodies" && p.selectedFromBody {selectedFromBody: selection};
//     }
//     then {
//         if (checkSAI({selection: selection, action: "ButtonPressed", input: -1})) {
//             modify(p, "selectedFromBody", null);
//             assert(new TPA(selection, "assignImage", getImageName(selection, false)));
//             halt();
//         } else {
//             backtrack();
//         }
//     }
// }

rule SelectTransferToBody {
    when {
        p: Problem p.subgoal == "selectTransferBodies" && p.selectedFromBody
            && !p.selectedToBody {selectedFromBody: fromBody};
        ie: InterfaceElement ie.name in diagramButtons {name: selection};
        arrow: Arrow arrow.fromBody == fromBody && arrow.toBody == selection
            && !arrow.completed {toBody: toBody};
    }
    then {
        if (checkSAI({selection: selection, action: "ButtonPressed", input: -1})) {
            modify(p, "selectedToBody", selection);
            modify(p, "subgoal", "enterArrowEnergy");
            assert(new TPA(selection, "assignImage", getImageName(selection, true)));
            assert(new TPA(arrow.name, "SetVisible", true));
            assert(new TPA(arrow.ieEnergyBox, "SetVisible", true));
            halt();
        } else {
            backtrack();
        }
    }
}

rule DuplicateSelectTransferToBody {
    when {
        p: Problem p.subgoal == "selectTransferBodies" && p.selectedFromBody
            && !p.selectedToBody {selectedFromBody: fromBody};
        ie: InterfaceElement ie.name in diagramButtons {name: selection};
        arrow: Arrow arrow.fromBody == fromBody && arrow.toBody == selection
            && arrow.completed {toBody: toBody};
    }
    then {
        if (checkSAI({selection: selection, action: "ButtonPressed", input: -1})) {
            // Reset selections
            modify(p, "selectedFromBody", null);
            assert(new TPA(fromBody, "assignImage", getImageName(fromBody, false)));
            setSuccessOrBugMsg("This arrow is already done.");
            assert(new TPA(fromBody, "unlock"));
            assert(new TPA(selection, "unlock"));
            // backtrack();
            halt();
        }
    }
}

rule BuggySelectTransferToBody {
    when {
        p: Problem p.subgoal == "selectTransferBodies" && p.selectedFromBody {selectedFromBody: fromBody};
        ie: InterfaceElement ie.name in diagramButtons {name: selection};
        not(arrow: Arrow arrow.fromBody == fromBody && arrow.toBody == selection {toBody: toBody});
    }
    then {
        if (checkSAI({selection: selection, action: "ButtonPressed", input: -1}, null, true)) {
            // Reset the "from" selection
            modify(p, "selectedFromBody", null);
            assert(new TPA(fromBody, "assignImage", getImageName(fromBody, false)));
            setSuccessOrBugMsg("There's no energy transfer from " + fromBody + " to " + selection + " in this model.");
            assert(new TPA(fromBody, "unlock"));
            assert(new TPA(selection, "unlock"));
            // backtrack();
            halt();
        }
    }
}

rule EnterArrowEnergy {
    when {
        p: Problem p.subgoal == "enterArrowEnergy" && p.selectedFromBody
            && selectedToBody {selectedFromBody: fromBody, selectedToBody: toBody};
        arrow: Arrow arrow.fromBody == fromBody && arrow.toBody == toBody;
        ie: InterfaceElement ie.name == arrow.ieEnergyBox {name: selection};
    }
    then {
        if (checkSAI({selection: selection, action: "UpdateComboBox", input: arrow.energy})) {
            modify(p, "subgoal", "selectTransferBodies");
            modify(p, "selectedFromBody", null);
            modify(p, "selectedToBody", null);
            modify(arrow, "completed", true);
            assert(new TPA(arrow.ieEnergyBox, "SetVisible", false));
            assert(new TPA(arrow.ieEnergyText, "SetVisible", true));
            assert(new TPA(fromBody, "assignImage", getImageName(fromBody, false)));
            assert(new TPA(toBody, "assignImage", getImageName(toBody, false)));
            assert(new TPA(fromBody, "unlock"));
            assert(new TPA(toBody, "unlock"));
            halt();
        } else {
            backtrack();
        }
    }
}

rule ConfirmIdentifiedAllTransfers {
    when {
        p: Problem p.subgoal == "selectTransferBodies";
        not(arrow: Arrow !arrow.completed);
    }
    then {
        if (checkSAI({selection: "step1-finish", action: "ButtonPressed", input: -1})) {
            setSuccessOrBugMsg("Great, you have identified all the energy transfers.");
        } else {
            backtrack();
        }
    }
}

rule BuggyConfirmIdentifiedAllTransfers {
    when {
        p: Problem p.subgoal == "selectTransferBodies";
        arrow: Arrow !arrow.completed;
    }
    then {
        if (checkSAI({selection: "step1-finish", action: "ButtonPressed", input: -1}, null, true)) {
            setSuccessOrBugMsg("I'm sorry, but you haven't identified all the transfers.");
            backtrack();
        }
    }
}


