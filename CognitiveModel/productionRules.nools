// @ts-nocheck

import("types.nools");

global SPACE = "space";
global SUN = "sun";
global LAYER1 = "layer1";
global LAYER2 = "layer2";
global SURFACE = "surface";

global DIAGRAM_BUTTONS = [SUN, SPACE, LAYER1, LAYER2, SURFACE];

global CV_SURFACE = "control-volume-surface";
global CV_LAYER1 = "control-volume-layer1";
global CV_LAYER2 = "control-volume-layer2";

global CONTROL_VOLUMES = [CV_SURFACE, CV_LAYER1, CV_LAYER2];
global ARROWS = ["arrow1", "arrow2", "arrow3", "arrow4", "arrow5", "arrow6"];

function getBodyImageName(label, active) {
    if (active) {
        return "Assets/" + label + "-active.png";
    } else {
        return "Assets/" + label + "-inactive.png";
    }
}

function switchToTab(tabNumber) {
    for (let i = 1; i <= 3; i += 1) {
        let labelName = ".tab-label.tab" + i;
        let mainName = ".steps-main.step" + i;
        if (i == tabNumber) {
            $(mainName).show();
            $(labelName).removeClass("disabled");
            $(".current-tab-bottombar").addClass("tab" + i);
        } else {
            $(mainName).hide();
            $(labelName).addClass("disabled");
            $(".current-tab-bottombar").removeClass("tab" + i);
        }
    }
}

function setupStep2() {
    for (let element of DIAGRAM_BUTTONS) {
        assert(new TPA(element, "lock"));
        $("#" + element).removeClass("step1");
    }
    $(".arrow").addClass("arrow-step2");
    for (let arrow of ARROWS) {
        assert(new TPA(arrow, "unlock"));
    }

    assert(new TPA(CV_SURFACE, "SetVisible", true));
    assert(new TPA(CV_LAYER1, "SetVisible", true));
    assert(new TPA(CV_LAYER2, "SetVisible", true));
}

function setStep2ControlVolumesSelectable(selectable) {
    if (selectable) {
        $(".control-volume-box").addClass("selection-target");
    } else {
        $(".control-volume-box").removeClass("selection-target");
    }
}

function setStep2ArrowsSelectable(selectable) {
    if (selectable) {
        $(".arrow").addClass("selection-target");
    } else {
        $(".arrow").removeClass("selection-target");
    }
}

// Render in & out MathML
function renderEquations(arrows, equation) {
    let inEquation = "<math xmlns=\"http:\/\/www.w3.org\/1998\/Math\/MathML\"><mrow>";
    let outEquation = "<math xmlns=\"http:\/\/www.w3.org\/1998\/Math\/MathML\"><mrow>";

    let componentDictionary = {
        "arrow1" : "<mfrac linethickness=\"1\"><mrow><mi>S</mi><mrow><mo form=\"prefix\">(</mo><mn>1</mn><mo>-</mo><mi>&#x003B1;</mi><mo form=\"postfix\">)</mo></mrow></mrow><mn>4</mn></mfrac>",
        "arrow2" : "<mi>&#x003C3;</mi><msup><mrow><msub><mi>T</mi><mi>S</mi></msub></mrow><mn>4</mn></msup>",
        "arrow3" : "<mi>&#x003C3;</mi><msup><mrow><msub><mi>T</mi><mi>1</mi></msub></mrow><mn>4</mn></msup>",
        "arrow4" : "<mi>&#x003C3;</mi><msup><mrow><msub><mi>T</mi><mi>1</mi></msub></mrow><mn>4</mn></msup>",
        "arrow5" : "<mi>&#x003C3;</mi><msup><mrow><msub><mi>T</mi><mi>2</mi></msub></mrow><mn>4</mn></msup>",
        "arrow6" : "<mi>&#x003C3;</mi><msup><mrow><msub><mi>T</mi><mi>2</mi></msub></mrow><mn>4</mn></msup>",
    };

    let inComponents = [];
    let outComponents = [];
    for (let arrow of arrows) {
        if (equation.inArrows.includes(arrow)) {
            inComponents.push(componentDictionary[arrow]);
        }
        if (equation.outArrows.includes(arrow)) {
            outComponents.push(componentDictionary[arrow]);
        }
    }

    if (inComponents.length > 0) {
        inEquation += inComponents[0];
        if (inComponents.length == 2) {
            inEquation += "<mo>+</mo>";
            inEquation += inComponents[1];
        }
    }

    if (outComponents.length > 0) {
        outEquation += outComponents[0];
        if (outComponents.length == 2) {
            outEquation += "<mo>+</mo>";
            outEquation += outComponents[1];
        }
    }

    inEquation += "</mrow></math>";
    outEquation += "</mrow></math>";

    console.log(inEquation);
    console.log(outEquation);
    

    return [inEquation, outEquation];
}

// For debugging
function fakeCompleteStep1(problem, arrows) {
    modify(problem, "subgoal", "selectTransferBodies");
    for (arrow of arrows) {
        modify(arrow, "completed", true);
        assert(new TPA(arrow.name, "SetVisible", true));
        assert(new TPA(arrow.ieEnergyText, "SetVisible", true));
    }
}


rule Bootstrap {
    when {
        bool : Boolean bool == false from false;
    }
    then {
        // Create Problem
        let problem = assert(new Problem("twoLayers"));

        // Step 1 diagram buttons
        assert(new InterfaceElement(SPACE));
        assert(new InterfaceElement(SUN));
        assert(new InterfaceElement(LAYER2));
        assert(new InterfaceElement(LAYER1));
        assert(new InterfaceElement(SURFACE));

        // Step 1 other buttons
        assert(new InterfaceElement("step1-finish"));
        assert(new InterfaceElement("step1-go-to-step2"));
        assert(new TPA("step1-go-to-step2", "SetVisible", false));

        // Step 1 all arrows
        let arrows = [
            assert(new Arrow("arrow1", SUN, SURFACE, "S(1-α)/4" )),
            assert(new Arrow("arrow2", SURFACE, LAYER1, "σTs^4" )),
            assert(new Arrow("arrow3", LAYER1, SURFACE, "σT1^4" )),
            assert(new Arrow("arrow4", LAYER1, LAYER2, "σT1^4" )),
            assert(new Arrow("arrow5", LAYER2, LAYER1, "σT2^4" )),
            assert(new Arrow("arrow6", LAYER2, SPACE, "σT2^4" ))
        ];
        for (arrow of arrows) {
            assert(new InterfaceElement(arrow.ieEnergyBox));
            assert(new InterfaceElement(arrow.ieEnergyText));
            assert(new TPA(arrow.name, "SetVisible", false));
            assert(new TPA(arrow.ieEnergyBox, "SetVisible", false));
            assert(new TPA(arrow.ieEnergyText, "SetVisible", false));
        }

        // Step 2 all equations
        let equations = [
            assert(new BalanceEquation(CV_SURFACE, ["arrow1", "arrow3"], ["arrow2"])),
            assert(new BalanceEquation(CV_LAYER1, ["arrow2", "arrow5"], ["arrow3", "arrow4"])),
            assert(new BalanceEquation(CV_LAYER2, ["arrow4"], ["arrow5", "arrow6"]))
        ];

        // Step 2 elements
        assert(new ControlVolumeElement(CV_SURFACE));
        assert(new ControlVolumeElement(CV_LAYER1));
        assert(new ControlVolumeElement(CV_LAYER2));
        assert(new TPA(CV_SURFACE, "SetVisible", false));
        assert(new TPA(CV_LAYER1, "SetVisible", false));
        assert(new TPA(CV_LAYER2, "SetVisible", false));

        // CTAT settings
        setProblemAttribute("use_backtracking", true);
        setProblemAttribute("prune_old_activations", true);
        // setProblemAttribute("substitute_input", true);

        // Debug: skip steps
        // fakeCompleteStep1(problem, arrows);


        switchToTab(1);

        halt();
    }
}

//////////////////////////
//        Step 1        //
//////////////////////////

rule SelectTransferFromBody {
    when {
        p: Problem p.subgoal == "selectTransferBodies" && !p.selectedFromBody;
        ie: InterfaceElement ie.name in DIAGRAM_BUTTONS {name: selection};
    }
    then {
        if (checkSAI({selection: selection, action: "ButtonPressed", input: -1})) {
            modify(p, "selectedFromBody", selection);
            assert(new TPA(selection, "assignImage", getBodyImageName(selection, true)));
            halt();
        } else {
            backtrack();
        }
    }
}

rule SelectTransferToBody {
    when {
        p: Problem p.subgoal == "selectTransferBodies" && p.selectedFromBody
            && !p.selectedToBody {selectedFromBody: fromBody};
        ie: InterfaceElement ie.name in DIAGRAM_BUTTONS {name: selection};
        arrow: Arrow arrow.fromBody == fromBody && arrow.toBody == selection
            && !arrow.completed {toBody: toBody};
    }
    then {
        if (checkSAI({selection: selection, action: "ButtonPressed", input: -1})) {
            modify(p, "selectedToBody", selection);
            modify(p, "subgoal", "enterArrowEnergy");
            assert(new TPA(selection, "assignImage", getBodyImageName(selection, true)));
            assert(new TPA(arrow.name, "SetVisible", true));
            assert(new TPA(arrow.ieEnergyBox, "SetVisible", true));
            halt();
        } else {
            backtrack();
        }
    }
}

rule DuplicateSelectTransferToBody {
    when {
        p: Problem p.subgoal == "selectTransferBodies" && p.selectedFromBody
            && !p.selectedToBody {selectedFromBody: fromBody};
        ie: InterfaceElement ie.name in DIAGRAM_BUTTONS {name: selection};
        arrow: Arrow arrow.fromBody == fromBody && arrow.toBody == selection
            && arrow.completed {toBody: toBody};
    }
    then {
        if (checkSAI({selection: selection, action: "ButtonPressed", input: -1})) {
            // Reset selections
            modify(p, "selectedFromBody", null);
            assert(new TPA(fromBody, "assignImage", getBodyImageName(fromBody, false)));
            setSuccessOrBugMsg("This arrow is already done.");
            assert(new TPA(fromBody, "unlock"));
            assert(new TPA(selection, "unlock"));
            // backtrack();
            halt();
        }
    }
}

rule BuggySelectTransferToBody {
    when {
        p: Problem p.subgoal == "selectTransferBodies" && p.selectedFromBody {selectedFromBody: fromBody};
        ie: InterfaceElement ie.name in DIAGRAM_BUTTONS {name: selection};
        not(arrow: Arrow arrow.fromBody == fromBody && arrow.toBody == selection {toBody: toBody});
    }
    then {
        if (checkSAI({selection: selection, action: "ButtonPressed", input: -1}, null, true)) {
            // Reset the "from" selection
            modify(p, "selectedFromBody", null);
            assert(new TPA(fromBody, "assignImage", getBodyImageName(fromBody, false)));
            setSuccessOrBugMsg("There's no energy transfer from " + fromBody + " to " + selection + " in this model.");
            assert(new TPA(fromBody, "unlock"));
            assert(new TPA(selection, "unlock"));
            // backtrack();
            halt();
        }
    }
}

rule EnterArrowEnergy {
    when {
        p: Problem p.subgoal == "enterArrowEnergy" && p.selectedFromBody
            && selectedToBody {selectedFromBody: fromBody, selectedToBody: toBody};
        arrow: Arrow arrow.fromBody == fromBody && arrow.toBody == toBody;
        ie: InterfaceElement ie.name == arrow.ieEnergyBox {name: selection};
    }
    then {
        if (checkSAI({selection: selection, action: "UpdateComboBox", input: arrow.energy})) {
            modify(p, "subgoal", "selectTransferBodies");
            modify(p, "selectedFromBody", null);
            modify(p, "selectedToBody", null);
            modify(arrow, "completed", true);
            assert(new TPA(arrow.ieEnergyBox, "SetVisible", false));
            assert(new TPA(arrow.ieEnergyText, "SetVisible", true));
            assert(new TPA(fromBody, "assignImage", getBodyImageName(fromBody, false)));
            assert(new TPA(toBody, "assignImage", getBodyImageName(toBody, false)));
            assert(new TPA(fromBody, "unlock"));
            assert(new TPA(toBody, "unlock"));
            halt();
        } else {
            backtrack();
        }
    }
}

rule ConfirmIdentifiedAllTransfers {
    when {
        p: Problem p.subgoal == "selectTransferBodies";
        not(arrow: Arrow !arrow.completed);
    }
    then {
        if (checkSAI({selection: "step1-finish", action: "ButtonPressed", input: -1})) {
            setSuccessOrBugMsg("Great, you have identified all the energy transfers.");
            modify(p, "subgoal", "goToStep2");
            assert(new TPA("step1-finish", "SetVisible", false));
            assert(new TPA("step1-go-to-step2", "SetVisible", true));
            halt();
        } else {
            backtrack();
        }
    }
}

rule BuggyConfirmIdentifiedAllTransfers {
    when {
        p: Problem p.subgoal == "selectTransferBodies";
        arrow: Arrow !arrow.completed;
    }
    then {
        if (checkSAI({selection: "step1-finish", action: "ButtonPressed", input: -1}, null, true)) {
            setSuccessOrBugMsg("I'm sorry, but you haven't identified all the transfers.");
            backtrack();
        }
    }
}

rule AdvanceFromStep1ToStep2 {
    when {
        p: Problem p.subgoal == "goToStep2";
    }
    then {
        if (checkSAI({selection: "step1-go-to-step2", action: "ButtonPressed", input: -1})) {
            modify(p, "subgoal", "selectControlVolume");
            // modify HTML
            switchToTab(2);
            setupStep2();

            halt();
        } else {
            backtrack();
        }
    }
}

//////////////////////////
//        Step 2        //
//////////////////////////

rule SelectControlVolume {
    when {
        p: Problem p.subgoal == "selectControlVolume" && !p.selectedControlVolume;
        volume: ControlVolumeElement !volume.completed {name: selection};
    }
    then {
        if (checkSAI({selection: selection, action: "ButtonPressed", input: -1})) {
            modify(p, "selectedControlVolume", selection);
            modify(p, "subgoal", "selectInAndOutArrows");
            modify(p, "currentEquationRow", 1);

            assert(new TPA(selection, "assignImage", "Assets/control-volume-box-active.png"));

            // Show row
            $(".step2-table-row").removeClass("hidden-row");

            // Put volume label in table
            let rowLabel = {
                [CV_LAYER1] : "Layer 1",
                [CV_LAYER2] : "Layer 2",
                [CV_SURFACE] : "Surface"
            }[selection];

            assert(new TPA("table-row-label-1", "UpdateTextField", rowLabel));

            setStep2ControlVolumesSelectable(false);
            setStep2ArrowsSelectable(true);

            halt();
        } else {
            backtrack();
        }
    }
}

rule SelectArrowForControlVolume {
    when {
        p: Problem p.subgoal == "selectInAndOutArrows" && p.selectedControlVolume;
        volume: ControlVolumeElement volume.name == p.selectedControlVolume &&
            !volume.completed;
        equation: BalanceEquation equation.name == volume.name;
        arrow: Arrow arrow.name in equation.allArrows {name: selection};
    }
    then {
        if (checkSAI({selection: selection, action: "ButtonPressed", input: -1})) {
            assert(new TPA(selection, "assignImage", "Assets/" + selection + ".png"));
            // check if this volume is completed, set it if so
            let arrows = p.currentSelectedArrows.slice();
            arrows.push(selection);
            modify(p, "currentSelectedArrows", arrows);

            if (arrows.length == equation.allArrows.length) {
                modify(volume, "completed", true);
            }

            let [inEquation, outEquation] = renderEquations(arrows, equation);
            assert(new TPA("table-row-energy-in-1", "UpdateTextField", inEquation));
            assert(new TPA("table-row-energy-out-1", "UpdateTextField", outEquation));

            halt();
        } else {
            backtrack();
        }
    }
}

