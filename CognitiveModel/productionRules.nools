// @ts-nocheck

import("types.nools");

global SPACE = "space";
global SUN = "sun";
global LAYER1 = "layer1";
global LAYER2 = "layer2";
global SURFACE = "surface";

global DIAGRAM_BUTTONS = [SUN, SPACE, LAYER1, LAYER2, SURFACE];

global CV_SURFACE = "control-volume-surface";
global CV_LAYER1 = "control-volume-layer1";
global CV_LAYER2 = "control-volume-layer2";

global CONTROL_VOLUMES = [CV_SURFACE, CV_LAYER1, CV_LAYER2];
global ARROWS = ["arrow1", "arrow2", "arrow3", "arrow4", "arrow5", "arrow6"];

function getBodyImageName(label, active) {
    if (active) {
        return "Assets/" + label + "-active.png";
    } else {
        return "Assets/" + label + "-inactive.png";
    }
}

function switchToTab(tabNumber) {
    for (let i = 1; i <= 3; i += 1) {
        let labelName = ".tab-label.tab" + i;
        let mainName = ".steps-main.step" + i;
        if (i == tabNumber) {
            $(mainName).show();
            $(labelName).removeClass("disabled");
            $(".current-tab-bottombar").addClass("tab" + i);
        } else {
            $(mainName).hide();
            $(labelName).addClass("disabled");
            $(".current-tab-bottombar").removeClass("tab" + i);
        }
    }
}

function setupStep2() {
    for (let element of DIAGRAM_BUTTONS) {
        assert(new TPA(element, "lock"));
        $("#" + element).removeClass("step1");
    }
    $(".arrow").addClass("arrow-step2");

    assert(new TPA(CV_SURFACE, "SetVisible", true));
    assert(new TPA(CV_LAYER1, "SetVisible", true));
    assert(new TPA(CV_LAYER2, "SetVisible", true));
}

function setStep2ControlVolumesSelectable(selectable) {
    if (selectable) {
        $(".control-volume-box").addClass("selection-target");
    } else {
        $(".control-volume-box").removeClass("selection-target");
    }
}

function setStep2ArrowsSelectable(selectable) {
    if (selectable) {
        $(".arrow").addClass("selection-target");
    } else {
        $(".arrow").removeClass("selection-target");
    }
}

// For debugging
function fakeCompleteStep1(problem, arrows) {
    modify(problem, "subgoal", "selectTransferBodies");
    for (arrow of arrows) {
        modify(arrow, "completed", true);
        assert(new TPA(arrow.name, "SetVisible", true));
        assert(new TPA(arrow.ieEnergyText, "SetVisible", true));
    }
}


rule Bootstrap {
    when {
        bool : Boolean bool == false from false;
    }
    then {
        // Create Problem
        let problem = assert(new Problem("twoLayers"));

        // Step 1 diagram buttons
        assert(new InterfaceElement(SPACE));
        assert(new InterfaceElement(SUN));
        assert(new InterfaceElement(LAYER2));
        assert(new InterfaceElement(LAYER1));
        assert(new InterfaceElement(SURFACE));

        // Step 1 other buttons
        assert(new InterfaceElement("step1-finish"));
        assert(new InterfaceElement("step1-go-to-step2"));
        assert(new TPA("step1-go-to-step2", "SetVisible", false));

        // Step 1 all arrows
        let arrows = [
            assert(new Arrow("arrow1", SUN, SURFACE, "S(1-α)/4" )),
            assert(new Arrow("arrow2", SURFACE, LAYER1, "σTs^4" )),
            assert(new Arrow("arrow3", LAYER1, SURFACE, "σT1^4" )),
            assert(new Arrow("arrow4", LAYER1, LAYER2, "σT1^4" )),
            assert(new Arrow("arrow5", LAYER2, LAYER1, "σT2^4" )),
            assert(new Arrow("arrow6", LAYER2, SPACE, "σT2^4" ))
        ];
        for (arrow of arrows) {
            assert(new InterfaceElement(arrow.ieEnergyBox));
            assert(new InterfaceElement(arrow.ieEnergyText));
            assert(new TPA(arrow.name, "SetVisible", false));
            assert(new TPA(arrow.ieEnergyBox, "SetVisible", false));
            assert(new TPA(arrow.ieEnergyText, "SetVisible", false));
        }

        // Step 2 elements
        assert(new ControlVolumeElement(CV_SURFACE));
        assert(new ControlVolumeElement(CV_LAYER1));
        assert(new ControlVolumeElement(CV_LAYER2));
        assert(new TPA(CV_SURFACE, "SetVisible", false));
        assert(new TPA(CV_LAYER1, "SetVisible", false));
        assert(new TPA(CV_LAYER2, "SetVisible", false));

        // CTAT settings
        setProblemAttribute("use_backtracking", true);
        setProblemAttribute("prune_old_activations", true);
        // setProblemAttribute("substitute_input", true);

        // Debug: skip steps
        // fakeCompleteStep1(problem, arrows);


        switchToTab(1);

        halt();
    }
}

//////////////////////////
//        Step 1        //
//////////////////////////

rule SelectTransferFromBody {
    when {
        p: Problem p.subgoal == "selectTransferBodies" && !p.selectedFromBody;
        ie: InterfaceElement ie.name in DIAGRAM_BUTTONS {name: selection};
    }
    then {
        if (checkSAI({selection: selection, action: "ButtonPressed", input: -1})) {
            modify(p, "selectedFromBody", selection);
            assert(new TPA(selection, "assignImage", getBodyImageName(selection, true)));
            halt();
        } else {
            backtrack();
        }
    }
}

rule SelectTransferToBody {
    when {
        p: Problem p.subgoal == "selectTransferBodies" && p.selectedFromBody
            && !p.selectedToBody {selectedFromBody: fromBody};
        ie: InterfaceElement ie.name in DIAGRAM_BUTTONS {name: selection};
        arrow: Arrow arrow.fromBody == fromBody && arrow.toBody == selection
            && !arrow.completed {toBody: toBody};
    }
    then {
        if (checkSAI({selection: selection, action: "ButtonPressed", input: -1})) {
            modify(p, "selectedToBody", selection);
            modify(p, "subgoal", "enterArrowEnergy");
            assert(new TPA(selection, "assignImage", getBodyImageName(selection, true)));
            assert(new TPA(arrow.name, "SetVisible", true));
            assert(new TPA(arrow.ieEnergyBox, "SetVisible", true));
            halt();
        } else {
            backtrack();
        }
    }
}

rule DuplicateSelectTransferToBody {
    when {
        p: Problem p.subgoal == "selectTransferBodies" && p.selectedFromBody
            && !p.selectedToBody {selectedFromBody: fromBody};
        ie: InterfaceElement ie.name in DIAGRAM_BUTTONS {name: selection};
        arrow: Arrow arrow.fromBody == fromBody && arrow.toBody == selection
            && arrow.completed {toBody: toBody};
    }
    then {
        if (checkSAI({selection: selection, action: "ButtonPressed", input: -1})) {
            // Reset selections
            modify(p, "selectedFromBody", null);
            assert(new TPA(fromBody, "assignImage", getBodyImageName(fromBody, false)));
            setSuccessOrBugMsg("This arrow is already done.");
            assert(new TPA(fromBody, "unlock"));
            assert(new TPA(selection, "unlock"));
            // backtrack();
            halt();
        }
    }
}

rule BuggySelectTransferToBody {
    when {
        p: Problem p.subgoal == "selectTransferBodies" && p.selectedFromBody {selectedFromBody: fromBody};
        ie: InterfaceElement ie.name in DIAGRAM_BUTTONS {name: selection};
        not(arrow: Arrow arrow.fromBody == fromBody && arrow.toBody == selection {toBody: toBody});
    }
    then {
        if (checkSAI({selection: selection, action: "ButtonPressed", input: -1}, null, true)) {
            // Reset the "from" selection
            modify(p, "selectedFromBody", null);
            assert(new TPA(fromBody, "assignImage", getBodyImageName(fromBody, false)));
            setSuccessOrBugMsg("There's no energy transfer from " + fromBody + " to " + selection + " in this model.");
            assert(new TPA(fromBody, "unlock"));
            assert(new TPA(selection, "unlock"));
            // backtrack();
            halt();
        }
    }
}

rule EnterArrowEnergy {
    when {
        p: Problem p.subgoal == "enterArrowEnergy" && p.selectedFromBody
            && selectedToBody {selectedFromBody: fromBody, selectedToBody: toBody};
        arrow: Arrow arrow.fromBody == fromBody && arrow.toBody == toBody;
        ie: InterfaceElement ie.name == arrow.ieEnergyBox {name: selection};
    }
    then {
        if (checkSAI({selection: selection, action: "UpdateComboBox", input: arrow.energy})) {
            modify(p, "subgoal", "selectTransferBodies");
            modify(p, "selectedFromBody", null);
            modify(p, "selectedToBody", null);
            modify(arrow, "completed", true);
            assert(new TPA(arrow.ieEnergyBox, "SetVisible", false));
            assert(new TPA(arrow.ieEnergyText, "SetVisible", true));
            assert(new TPA(fromBody, "assignImage", getBodyImageName(fromBody, false)));
            assert(new TPA(toBody, "assignImage", getBodyImageName(toBody, false)));
            assert(new TPA(fromBody, "unlock"));
            assert(new TPA(toBody, "unlock"));
            halt();
        } else {
            backtrack();
        }
    }
}

rule ConfirmIdentifiedAllTransfers {
    when {
        p: Problem p.subgoal == "selectTransferBodies";
        not(arrow: Arrow !arrow.completed);
    }
    then {
        if (checkSAI({selection: "step1-finish", action: "ButtonPressed", input: -1})) {
            setSuccessOrBugMsg("Great, you have identified all the energy transfers.");
            modify(p, "subgoal", "goToStep2");
            assert(new TPA("step1-finish", "SetVisible", false));
            assert(new TPA("step1-go-to-step2", "SetVisible", true));
            halt();
        } else {
            backtrack();
        }
    }
}

rule BuggyConfirmIdentifiedAllTransfers {
    when {
        p: Problem p.subgoal == "selectTransferBodies";
        arrow: Arrow !arrow.completed;
    }
    then {
        if (checkSAI({selection: "step1-finish", action: "ButtonPressed", input: -1}, null, true)) {
            setSuccessOrBugMsg("I'm sorry, but you haven't identified all the transfers.");
            backtrack();
        }
    }
}

rule AdvanceFromStep1ToStep2 {
    when {
        p: Problem p.subgoal == "goToStep2";
    }
    then {
        if (checkSAI({selection: "step1-go-to-step2", action: "ButtonPressed", input: -1})) {
            modify(p, "subgoal", "selectControlVolume");
            // modify HTML
            switchToTab(2);
            setupStep2();

            halt();
        } else {
            backtrack();
        }
    }
}

//////////////////////////
//        Step 1        //
//////////////////////////

rule SelectControlVolume {
    when {
        p: Problem p.subgoal == "selectControlVolume" && !p.selectedControlVolume;
        volume: ControlVolumeElement !volume.completed {name: selection};
    }
    then {
        if (checkSAI({selection: selection, action: "ButtonPressed", input: -1})) {
            modify(p, "selectedControlVolume", selection);
            modify(p, "subgoal", "selectInAndOutArrows");
            modify(p, "currentEquationRow", 1);

            assert(new TPA(selection, "assignImage", "Assets/control-volume-box-active.png"));

            // Put volume label in table

            setStep2ControlVolumesSelectable(false);
            setStep2ArrowsSelectable(true);

            halt();
        } else {
            backtrack();
        }
    }
}

